#! /usr/bin/python3
#
#   Copyright 2017, 2018, 2019 Zack Weinberg
#
#   This library is free software; you can redistribute it and/or
#    modify it under the terms of the GNU Lesser General Public License
#   as published by the Free Software Foundation; either version 2.1 of
#   the License, or (at your option) any later version.
#
#   This library is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU Lesser General Public License for more details.
#
#   You should have received a copy of the GNU Lesser General Public
#   License along with this library; if not, see
#   <https://www.gnu.org/licenses/>.

"""Generate crypt.h and xcrypt.h from their respective .in files plus
build configuration."""

import argparse
import ast
import re
import sys

from common import (
    atomic_update_file,
    ensure_C_locale,
)

from io import TextIOBase as TextIO
from typing import (
    Dict,
    Iterable,
    Mapping,
    Optional,
)

_substitute_re = re.compile("@[a-zA-Z0-9_]*@")


def substitute_file(ofp: TextIO,
                    ifp: TextIO,
                    ifname: str,
                    substs: Mapping[str, str]) -> None:
    sub = _substitute_re.sub
    error = False
    for lineno, line in enumerate(ifp):
        try:
            line = sub(lambda m: substs[m.group(0)], line)
        except KeyError as e:
            sys.stderr.write("{}:{}: error: unknown substitution {}\n"
                             .format(ifname, lineno+1, e))
            error = True

        ofp.write(line)

    if error:
        sys.exit(1)


def extract_pp_macros(header: str,
                      macros: Iterable[str]) -> Mapping[str, Optional[str]]:
    """Extract the definitions of the macros MACROS (an iterable of strings)
       from the C header file HEADER.  Does not attempt to implement anything
       like the full complexity of C preprocessing; just looks for lines that
       begin '#define IDENTIFIER'.  This is good enough for configuration
       headers generated by autoconf."""
    definitions: Dict[str, Optional[str]] = {
        m: None for m in macros
    }
    if header is not None:
        with open(header, "rt", encoding="utf-8") as fp:
            for line in fp:
                if line.startswith("#define"):
                    toks = line.split(None, 2)
                    name = toks[1]
                    replacement = (toks[2] if len(toks) == 3 else "")
                    if name in definitions:
                        definitions[name] = replacement.strip()
    return definitions


def is_truthy(definitions: Mapping[str, Optional[str]],
              macro: str) -> bool:
    """True if DEFINITIONS includes MACRO with a value that is truthy
       according to C (more or less)."""
    defn = definitions.get(macro)

    # macros that are not defined are falsey
    if defn is None:
        return False

    # for historical reasons, C preprocessor macros with an empty
    # replacement are *truthy*
    if defn == "":
        return True

    # zero and one are the standard C false and true, respectively
    if defn == "0":
        return False
    if defn == "1":
        return True

    # strings shouldn't appear here
    if defn[0] in ('"', "'"):
        raise ValueError("don't call is_truthy on a macro defined to a string")

    # attempt to handle things like '(0)' and '(1-1)' with ast.literal_eval
    try:
        if ast.literal_eval(defn):
            return True
        return False
    except (SyntaxError, ValueError):
        return False


def compute_substitutions(args: argparse.Namespace) -> Dict[str, str]:
    config_macros = extract_pp_macros(args.config_h, [
        "HAVE_SYS_CDEFS_H",
        "HAVE_SYS_CDEFS_BEGIN_END_DECLS",
        "HAVE_SYS_CDEFS_THROW",
        "PACKAGE_VERSION"
    ])
    hashes_macros = extract_pp_macros(args.hashes_h, [
        "HASH_ALGORITHM_DEFAULT"
    ])

    cdefs_h = is_truthy(config_macros, "HAVE_SYS_CDEFS_H")
    cdefs_decls = is_truthy(config_macros, "HAVE_SYS_CDEFS_BEGIN_END_DECLS")
    cdefs_throw = is_truthy(config_macros, "HAVE_SYS_CDEFS_THROW")
    if not cdefs_h and (cdefs_decls or cdefs_throw):
        sys.stderr.write(
            "error: cdefs_decls and/or cdefs_throw but not cdefs_h\n")
        sys.exit(1)

    header_lines = []
    if cdefs_h:
        header_lines.append("#include <sys/cdefs.h>")
    if not cdefs_throw:
        header_lines.append("#define __THROW /* nothing */")
    header = "\n".join(header_lines)

    if cdefs_decls:
        begin_decls = "__BEGIN_DECLS"
        end_decls = "__END_DECLS"
    else:
        begin_decls = "#ifdef __cplusplus\nextern \"C\" {\n#endif"
        end_decls = "#ifdef __cplusplus\n} /* extern \"C\" */\n#endif"

    xcrypt_version_str = config_macros["PACKAGE_VERSION"]
    if xcrypt_version_str is None:
        sys.stderr.write("error: PACKAGE_VERSION was not defined")
        sys.exit(1)
    xcrypt_version_arr = xcrypt_version_str[1:-1].split('.')
    xcrypt_version_major = xcrypt_version_arr[0]
    xcrypt_version_minor = xcrypt_version_arr[1]

    if hashes_macros["HASH_ALGORITHM_DEFAULT"] is not None:
        default_prefix_enabled = "1"
    else:
        default_prefix_enabled = "0"

    return {
        "@@": "@",
        "@HEADER@": header,
        "@BEGIN_DECLS@": begin_decls,
        "@END_DECLS@": end_decls,
        "@DEFAULT_PREFIX_ENABLED@": default_prefix_enabled,
        "@XCRYPT_VERSION_STR@": xcrypt_version_str,
        "@XCRYPT_VERSION_MAJOR@": xcrypt_version_major,
        "@XCRYPT_VERSION_MINOR@": xcrypt_version_minor,
    }


def main() -> None:
    ap = argparse.ArgumentParser(description=__doc__)
    ap.add_argument("--hashes-h",
                    help="Pathname of crypt-hashes.h, which will be examined "
                    "to find out whether a default prefix is enabled")
    ap.add_argument("--config-h",
                    help="Pathname of the Autoconf-generated config.h, which "
                    "will be examined for details of build configuration")

    ap.add_argument("output", help="Where to write the generated header")
    ap.add_argument("input", help="Input template for the generated header")

    args = ap.parse_args()

    ensure_C_locale()

    substs = compute_substitutions(args)

    try:
        with open(args.input, "rt", encoding="utf-8") as ifp:
            with atomic_update_file(args.output) as ofp:
                assert isinstance(ofp, TextIO)
                substitute_file(ofp, ifp, args.input, substs)

    except Exception as e:
        sys.stderr.write("gen-crypt-h: {}\n".format(str(e)))
        sys.exit(1)

    sys.exit(0)


main()
