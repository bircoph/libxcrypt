#! /usr/bin/python3
#
#   Copyright 2017, 2018, 2019 Zack Weinberg
#
#   This library is free software; you can redistribute it and/or
#    modify it under the terms of the GNU Lesser General Public License
#   as published by the Free Software Foundation; either version 2.1 of
#   the License, or (at your option) any later version.
#
#   This library is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU Lesser General Public License for more details.
#
#   You should have received a copy of the GNU Lesser General Public
#   License along with this library; if not, see
#   <https://www.gnu.org/licenses/>.

"""Generate crypt-symbol-vers.h from libcrypt.map.in and build
configuration."""

# See libcrypt.map.in and gen-libcrypt-map for explanations of the format
# of .map.in files.  See crypt-port.h for an explanation of how to use
# the macros generated by this program.
#
# Note: if you change the format of .map.in files you probably need to
# update gen-libcrypt-map too.
#
# Note: we currently don't support compatibility symbols that need
# a different definition from the default version.

import argparse
import collections
import sys

from common import (
    atomic_update_file,
    ensure_C_locale
)

from io import TextIOBase as TextIO
from typing import (
    DefaultDict,
    List,
    Set,
)


def gen_symbol_vers(ofp: TextIO,
                    ifp: TextIO,
                    ifname: str, *,
                    symver_min: str,
                    symver_floor: str,
                    compat_api: str) -> None:

    symbols: DefaultDict[str, List[str]] = collections.defaultdict(list)
    vchain = []
    compat_only = {}
    error = False

    for lineno, line in enumerate(ifp):
        line = line.strip()
        if not line:
            continue
        if line[0] == '#':
            continue

        F = line.split()
        if len(F) < 2:
            sys.stderr.write("{}:{}: error: incomplete line\n".format(
                ifname, lineno+1))
            error = True
            continue

        if F[0] == "%chain":
            vchain.extend(F[1:])
            continue

        sym = F[0]
        dver = F[1]
        if dver == "-":
            compat_only[sym] = True
        else:
            compat_only[sym] = False
            symbols[dver].append(sym)

        for ver in F[2:]:
            ver, _, tags = ver.partition(":")
            if (
                    tags == ""
                    or compat_api == "true"
                    or compat_api in tags.split(":")
            ):
                symbols[ver].append(sym)

    if not vchain:
        sys.stderr.write(ifname + ": error: missing %chain directive\n")
        sys.exit(1)

    try:
        symver_min_idx = vchain.index(symver_min)
    except ValueError:
        sys.stderr.write("{}: error: symver_min {!r} "
                         "not found in %chain directives\n"
                         .format(ifname, symver_min))
        error = True

    try:
        symver_floor_idx = vchain.index(symver_floor)
    except ValueError:
        sys.stderr.write("{}: error: symver_floor {!r} "
                         "not found in %chain directives\n"
                         .format(ifname, symver_floor))
        error = True

    if error:
        sys.exit(1)

    if symver_floor_idx < symver_min_idx:
        sys.stderr.write("{}: error: symver_floor {!r} "
                         "is lower than symver_min {!r}\n"
                         .format(ifname, symver_floor, symver_min))
        sys.exit(1)

    # Construct a pruned set of symbols and versions, including only
    # versions with symbols, discarding all symbols associated with
    # versions below SYMVER_MIN, raising symbols below SYMVER_FLOOR to
    # SYMVER_FLOOR, and removing duplicates.
    # Note: unlike in gen-libcrypt-map, symbols all of whose versions
    # are below SYMVER_MIN must still be counted in 'allsyms' so their
    # INCLUDE macros are generated.
    allsyms_set = set()
    symset: DefaultDict[str, Set[str]] = collections.defaultdict(set)
    for i, v in enumerate(vchain):
        syms = symbols[v]
        if syms:
            ver = vchain[max(i, symver_floor_idx)]
            for s in syms:
                allsyms_set.add(s)
                if i >= symver_min_idx:
                    symset[ver].add(s)

    allsyms = sorted(allsyms_set)
    vchain = vchain[symver_floor_idx:]

    ofp.write(
        "/* Generated from {} and build config.  DO NOT EDIT.  */\n"
        .format(ifname)
    )
    ofp.write(
        "\n"
        "#ifndef _CRYPT_SYMBOL_VERS_H\n"
        "#define _CRYPT_SYMBOL_VERS_H 1\n"
        "\n"
        "/* For each public symbol <sym>, INCLUDE_<sym> is true if it\n"
        "   has any versions above the backward compatibility minimum.\n"
        "   Compatibility-only symbols are not included in the static\n"
        "   library, or in the shared library when configured with\n"
        "   --disable-obsolete-api.  */\n"
        "#if defined PIC && ENABLE_OBSOLETE_API\n"
        "\n"
    )

    includesym = {}
    for sym in allsyms:
        for ver in vchain:
            if sym in symset[ver]:
                includesym[sym] = include = 1
                break
        else:
            includesym[sym] = include = 0
        ofp.write("#define INCLUDE_{} {}\n".format(sym, include))

    ofp.write(
        "\n"
        "#else\n"
        "\n"
    )
    for sym in allsyms:
        ofp.write("#define INCLUDE_{} {}\n".format(
            sym, (1 if includesym[sym] and not compat_only[sym] else 0)))

    ofp.write(
        "\n"
        "#endif\n"
        "\n"
        "/* For each public symbol <sym> that is included, define its\n"
        "   highest version as the default, and aliases at each\n"
        "   compatibility version. */\n"
    )
    for sym in allsyms:
        if not includesym[sym]:
            ofp.write("#define SYMVER_{} symver_nop()\n".format(sym))
            continue

        seq = 0
        for ver in reversed(vchain):
            if sym not in symset[ver]:
                continue
            if seq == 0:
                ofp.write(
                    "#ifdef PIC\n#define {0} _crypt_{0}\n#endif\n"
                    .format(sym)
                )
                ofp.write("#define SYMVER_{} \\\n".format(sym))
                if compat_only[sym]:
                    ofp.write("  symver_compat0 (\"{s}\", {s}, {v})"
                              .format(s=sym, v=ver))
                else:
                    ofp.write("  symver_default (\"{s}\", {s}, {v})"
                              .format(s=sym, v=ver))

            else:
                ofp.write(
                    "; \\\n"
                    "  symver_compat ({i}, \"{s}\", {s}, {s}, {v})"
                    .format(i=seq, s=sym, v=ver))
            seq += 1
        ofp.write("\n")

    ofp.write("\n#endif /* crypt-symbol-vers.h */\n")


def main() -> None:
    ap = argparse.ArgumentParser(description=__doc__)
    ap.add_argument("--symver-min",
                    help="Minimum symbol version; versions lower than this "
                    "will be discarded.")
    ap.add_argument("--symver-floor",
                    help="Floor symbol version; versions lower than this "
                    "will be raised to this.")
    ap.add_argument("--compat-api", help="")
    ap.add_argument("output", help="Name of file to generate.")
    ap.add_argument("input", help="Name of file listing all symbol versions.")
    args = ap.parse_args()

    ensure_C_locale()

    try:
        with open(args.input, "rt", encoding="utf-8") as ifp:
            with atomic_update_file(args.output) as ofp:
                assert isinstance(ofp, TextIO)
                gen_symbol_vers(ofp, ifp, args.input,
                                symver_min=args.symver_min,
                                symver_floor=args.symver_floor,
                                compat_api=args.compat_api)

    except Exception as e:
        sys.stderr.write("gen-crypt-symbol-vers-h: {}\n".format(str(e)))
        sys.exit(1)

    sys.exit(0)


main()
